<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Technical Deep Dive: Optimizing Ubiquitous Cube Game - Maciej's Dev Blog</title>
    <link rel="stylesheet" href="/styles.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>Maciej's Dev Blog</h1>
            <nav>
                <a href="/index.html">Home</a>
                <a href="/blog.html">Blog</a>
                <a href="/resume.html">Resume</a>
                <a href="https://github.com/Xata" target="_blank">GitHub</a>
                <a href="https://www.linkedin.com/in/maciejwal/" target="_blank">LinkedIn</a>
            </nav>
        </header>

        <main class="content">
            <div class="article-meta">Posted on October 07, 2025</div>
<p><img alt="Ubiquitous Cube Game world" src="../img/cube-game-screenshot-00.jpg" /></p>
<h2>Performance is king</h2>
<p>I've been working on optimizing the voxel engine for Ubiquitous Cube Game and wanted to share some of the technical decisions that went into making it run at 100+ FPS (on my M2 MacBook Pro). When you're rendering thousands of voxels in real-time, every optimization matters. Here's what I learned about squeezing performance out of Python and OpenGL on macOS.</p>
<h2>The JIT compilation breakthrough</h2>
<p>One of the biggest wins came from using Numba's <code>@njit</code> decorator on the hot paths. The mesh building and terrain generation code gets called constantly, so I needed them to run at quickly. Numba's JIT compilation takes Python code and compiles it to native machine code at runtime. If I wanted the greedy meshing algorithm to work, I needed to use Numba's JIT compliation.</p>
<h2>Greedy meshing and why it matters</h2>
<p>The algorithm "greedily" combines adjacent faces of the same type into larger quads. This reduces the vertex count dramatically. A 32x32x32 chunk could theoretically have 32,768 voxels, but with greedy meshing we're only rendering the surfaces. Could you imagine how slow things would be if we needed to render each face on those 32,768?</p>
<h2>Packing vertex data tight</h2>
<p>This is really cool: I pack 7 vertex attributes into a single <code>uint32</code> per vertex. This includes position, normal, texture coordinates, and ambient occlusion data. The GPU unpacks these in the vertex shader using bit manipulation.</p>
<pre class="codehilite"><code class="language-glsl">// Unpack position from packed data
vec3 position = vec3(
    float((packedData &gt;&gt; 0) &amp; 0x3F),
    float((packedData &gt;&gt; 6) &amp; 0x3F),
    float((packedData &gt;&gt; 12) &amp; 0x3F)
);
</code></pre>

<p>Tighter data means better cache utilization, both on the CPU and GPU sides. The only problem is I have to manually track the bit manipulation but as long as I don't add any other futures. It won't be too bad.</p>
<h2>Two-pass rendering for transparency</h2>
<p>Real water is transparent, but transparency in 3D rendering is tricky. You need to render opaque objects first (with depth writing enabled), then render transparent objects sorted back-to-front (with depth testing but no depth writing).</p>
<p>I ended up implementing a two-pass pipeline:
1. First pass: solid geometry with full depth buffer writes (your regular blocks from the world)
2. Second pass: transparent water with depth test only (maybe other transparent blocks in the future?)</p>
<p>The water shader has some nice effects too. I looked up this thing called <code>Fresnel reflections</code>, animated wave ripples using time-based UV offsets, and volumetric fog that gets denser with depth. All running in GLSL.</p>
<h2>Why this matters for platform engineering</h2>
<p>Ahah, you might be wondering, "Why is a platform engineer wasting their time with game dev?"</p>
<p>Oh I got the answer for you: performance optimization is performance optimization (also I started out doing game dev back in the day so this is just nice to do). Whether you're optimizing game engine render loops or optimizing Kubernetes resource allocation, the principles are the same:</p>
<ul>
<li>Profile first, optimize second. Don't try to guess where the bottlenecks are.</li>
<li>Batch operations when possible. Your GPU wants large batches, and hopefully so does your database.</li>
<li>Spatial partitioning works for voxels and for distributed systems.</li>
</ul>
<p>I've used the same performance mindset when optimizing Fluent-bit configurations and tuning OpenSearch cluster performance at work. The tools change but the thinking doesn't.</p>
<h2>What's next</h2>
<p>Right now I'm working on adding an entity system for dropped items. When you break a block, it should drop as an entity that you can pick up. I also need to add a proper inventory system and a pause menu. I've implemented somewhat of a GUI manager but we'll see how this ends up.</p>
<p>The code is up on GitHub if you want to check it out: <a href="https://github.com/Xata/ubiquitous-cube-game">ubiquitous-cube-game</a></p>
<p>Anyway, that's my breakdown. Performance optimization is fun when you can actually see the FPS counter go up.</p>
        </main>

        <footer>
            <p>&copy; 2024-2025 Maciej Wal. Built with Python and simplicity.</p>
        </footer>
    </div>
</body>
</html>
